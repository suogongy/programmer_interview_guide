# åŒºå—é“¾æŠ€æœ¯ - æ€»è§ˆ

## æ¦‚è¿°

åŒºå—é“¾æŠ€æœ¯ä½œä¸ºWeb3æ—¶ä»£çš„æ ¸å¿ƒåŸºç¡€è®¾æ–½ï¼Œæ­£åœ¨é‡å¡‘æ•°å­—ä¸–ç•Œçš„ä¿¡ä»»æœºåˆ¶å’Œä»·å€¼äº¤æ¢æ–¹å¼ã€‚æœ¬ç« èŠ‚æ·±å…¥ä»‹ç»åŒºå—é“¾åŸºç¡€åŸç†ã€æ™ºèƒ½åˆçº¦å¼€å‘ã€DeFiåº”ç”¨æ„å»ºã€Web3æŠ€æœ¯æ ˆç­‰å†…å®¹ï¼Œå¸®åŠ©ä¼ ç»Ÿç¨‹åºå‘˜æŒæ¡è¿™ä¸€å‰æ²¿æŠ€æœ¯ã€‚

## ğŸ“š ç« èŠ‚å†…å®¹

### 1. [åŒºå—é“¾åŸºç¡€åŸç†](./blockchain-fundamentals.md)
- **åˆ†å¸ƒå¼è´¦æœ¬**: å»ä¸­å¿ƒåŒ–ã€ä¸å¯ç¯¡æ”¹ã€é€æ˜å¯è¿½æº¯
- **å…±è¯†æœºåˆ¶**: PoWã€PoSã€DPoSã€å®ç”¨æ‹œå åº­å®¹é”™
- **å¯†ç å­¦åŸºç¡€**: å“ˆå¸Œå‡½æ•°ã€æ•°å­—ç­¾åã€Merkleæ ‘
- **ç½‘ç»œæ¶æ„**: P2Pç½‘ç»œã€èŠ‚ç‚¹ç±»å‹ã€æ•°æ®åŒæ­¥
- **ç»æµæ¨¡å‹**: Tokenç»æµå­¦ã€æ¿€åŠ±æœºåˆ¶ã€æ²»ç†æ¨¡å¼

### 2. [æ™ºèƒ½åˆçº¦å¼€å‘](./smart-contracts.md)
- **Solidityç¼–ç¨‹**: è¯­æ³•åŸºç¡€ã€åˆçº¦ç»“æ„ã€æœ€ä½³å®è·µ
- **å¼€å‘ç¯å¢ƒ**: Hardhatã€Truffleã€Remix IDE
- **åˆçº¦æ¨¡å¼**: ä»£ç†æ¨¡å¼ã€å·¥å‚æ¨¡å¼ã€è®¿é—®æ§åˆ¶
- **å®‰å…¨å®¡è®¡**: å¸¸è§æ¼æ´ã€å®‰å…¨å·¥å…·ã€å®¡è®¡æµç¨‹
- **Gasä¼˜åŒ–**: å­˜å‚¨ä¼˜åŒ–ã€è®¡ç®—ä¼˜åŒ–ã€éƒ¨ç½²ä¼˜åŒ–

### 3. [DeFiåº”ç”¨å¼€å‘](./defi-development.md)
- **DeFiåè®®**: Uniswapã€Compoundã€Aaveã€MakerDAO
- **æµåŠ¨æ€§æŒ–çŸ¿**: AMMæœºåˆ¶ã€æ”¶ç›Šå†œåœºã€è´¨æŠ¼å¥–åŠ±
- **è·¨é“¾æ¡¥æ¥**: å¤šé“¾éƒ¨ç½²ã€èµ„äº§è·¨é“¾ã€äº’æ“ä½œæ€§
- **ä»·æ ¼é¢„è¨€æœº**: Chainlinkã€Band Protocolã€ä»·æ ¼èšåˆ
- **æ²»ç†ä»£å¸**: DAOæ²»ç†ã€æŠ•ç¥¨æœºåˆ¶ã€ææ¡ˆæµç¨‹

### 4. [Web3æŠ€æœ¯æ ˆ](./web3-stack.md)
- **å‰ç«¯æ¡†æ¶**: Web3.jsã€Ethers.jsã€Reacté›†æˆ
- **é’±åŒ…é›†æˆ**: MetaMaskã€WalletConnectã€å¤šé’±åŒ…æ”¯æŒ
- **IPFSå­˜å‚¨**: åˆ†å¸ƒå¼å­˜å‚¨ã€å†…å®¹å¯»å€ã€æ–‡ä»¶ç®¡ç†
- **The Graph**: é“¾ä¸Šæ•°æ®ç´¢å¼•ã€GraphQLæŸ¥è¯¢ã€å­å›¾å¼€å‘
- **Layer 2**: Polygonã€Arbitrumã€Optimismæ‰©å®¹æ–¹æ¡ˆ

### 5. [NFTç”Ÿæ€ç³»ç»Ÿ](./nft-ecosystem.md)
- **NFTæ ‡å‡†**: ERC-721ã€ERC-1155ã€å…ƒæ•°æ®æ ‡å‡†
- **å¸‚åœºå¼€å‘**: OpenSeaã€è‡ªå»ºå¸‚åœºã€æ‹å–æœºåˆ¶
- **æ•°å­—è‰ºæœ¯**: ç”Ÿæˆè‰ºæœ¯ã€PFPé¡¹ç›®ã€å®ç”¨æ€§NFT
- **æ¸¸æˆåŒ–åº”ç”¨**: GameFiã€P2Eã€è™šæ‹Ÿä¸–ç•Œ
- **ç‰ˆæƒä¿æŠ¤**: çŸ¥è¯†äº§æƒã€åˆ›ä½œè€…ç»æµã€æ”¶ç›Šåˆ†æˆ

## ğŸ¯ åŒºå—é“¾æŠ€æœ¯æ ˆ

### æ ¸å¿ƒæŠ€æœ¯ç»„ä»¶

#### 1. åŒºå—é“¾å¹³å°
```
ä¸»æµå…¬é“¾:
Ethereum (ä»¥å¤ªåŠ):
â€¢ æ™ºèƒ½åˆçº¦å¹³å°å…ˆé©±
â€¢ EVMæ‰§è¡Œç¯å¢ƒ
â€¢ ä¸°å¯Œçš„ç”Ÿæ€ç³»ç»Ÿ
â€¢ Gasè´¹ç”¨è¾ƒé«˜

Polygon (Matic):
â€¢ ä»¥å¤ªåŠLayer 2æ‰©å®¹
â€¢ ä½è´¹ç”¨å¿«é€Ÿç¡®è®¤
â€¢ å…¼å®¹EVM
â€¢ æ´»è·ƒçš„DeFiç”Ÿæ€

Solana:
â€¢ é«˜æ€§èƒ½åŒºå—é“¾
â€¢ ä½å»¶è¿Ÿé«˜åå
â€¢ Rustæ™ºèƒ½åˆçº¦
â€¢ å¿«é€Ÿå‘å±•çš„ç”Ÿæ€
```

#### 2. å¼€å‘å·¥å…·é“¾
```
æ™ºèƒ½åˆçº¦å¼€å‘:
â€¢ Solidity: ä»¥å¤ªåŠåˆçº¦è¯­è¨€
â€¢ Hardhat: å¼€å‘æµ‹è¯•æ¡†æ¶
â€¢ OpenZeppelin: å®‰å…¨åˆçº¦åº“
â€¢ Slither: é™æ€åˆ†æå·¥å…·

å‰ç«¯å¼€å‘:
â€¢ Web3.js: ä»¥å¤ªåŠJavaScript API
â€¢ Ethers.js: ç°ä»£åŒ–Web3åº“
â€¢ Wagmi: React Hooks for Ethereum
â€¢ RainbowKit: é’±åŒ…è¿æ¥ç»„ä»¶
```

### æ™ºèƒ½åˆçº¦ç¤ºä¾‹

#### ERC-20ä»£å¸åˆçº¦
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract MyToken is ERC20, Ownable {
    uint256 private constant MAX_SUPPLY = 1000000 * 10**18;
    
    constructor() ERC20("MyToken", "MTK") {
        _mint(msg.sender, 100000 * 10**18); // åˆå§‹å‘è¡Œ
    }
    
    function mint(address to, uint256 amount) public onlyOwner {
        require(totalSupply() + amount <= MAX_SUPPLY, "Exceeds max supply");
        _mint(to, amount);
    }
    
    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
    }
}
```

#### ç®€å•DeFiè´¨æŠ¼åˆçº¦
```solidity
contract StakingPool {
    IERC20 public stakingToken;
    IERC20 public rewardToken;
    
    uint256 public rewardRate = 100; // æ¯ç§’å¥–åŠ±
    uint256 public lastUpdateTime;
    uint256 public rewardPerTokenStored;
    
    mapping(address => uint256) public userRewardPerTokenPaid;
    mapping(address => uint256) public rewards;
    mapping(address => uint256) public balances;
    
    uint256 private _totalSupply;
    
    function stake(uint256 amount) external updateReward(msg.sender) {
        require(amount > 0, "Cannot stake 0");
        _totalSupply += amount;
        balances[msg.sender] += amount;
        stakingToken.transferFrom(msg.sender, address(this), amount);
    }
    
    function withdraw(uint256 amount) public updateReward(msg.sender) {
        require(amount > 0, "Cannot withdraw 0");
        _totalSupply -= amount;
        balances[msg.sender] -= amount;
        stakingToken.transfer(msg.sender, amount);
    }
    
    function getReward() public updateReward(msg.sender) {
        uint256 reward = rewards[msg.sender];
        if (reward > 0) {
            rewards[msg.sender] = 0;
            rewardToken.transfer(msg.sender, reward);
        }
    }
    
    modifier updateReward(address account) {
        rewardPerTokenStored = rewardPerToken();
        lastUpdateTime = block.timestamp;
        
        if (account != address(0)) {
            rewards[account] = earned(account);
            userRewardPerTokenPaid[account] = rewardPerTokenStored;
        }
        _;
    }
}
```

## ğŸ’¡ DeFiå¼€å‘å®è·µ

### è‡ªåŠ¨åšå¸‚å•†(AMM)åŸç†

#### Uniswap V2æ ¸å¿ƒé€»è¾‘
```solidity
// æ’å®šä¹˜ç§¯å…¬å¼: x * y = k
contract UniswapV2Pair {
    uint112 private reserve0;
    uint112 private reserve1;
    
    function swap(uint amount0Out, uint amount1Out, address to) external {
        require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');
        
        (uint112 _reserve0, uint112 _reserve1,) = getReserves();
        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');
        
        // è½¬è´¦
        if (amount0Out > 0) _safeTransfer(token0, to, amount0Out);
        if (amount1Out > 0) _safeTransfer(token1, to, amount1Out);
        
        // éªŒè¯æ’å®šä¹˜ç§¯å…¬å¼
        uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));
        uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));
        require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');
    }
}
```

### Web3å‰ç«¯é›†æˆ

#### React + Web3é›†æˆç¤ºä¾‹
```typescript
import { useState, useEffect } from 'react';
import { ethers } from 'ethers';
import { useAccount, useConnect, useDisconnect } from 'wagmi';

function TokenSwap() {
  const { address, isConnected } = useAccount();
  const { connect, connectors } = useConnect();
  const { disconnect } = useDisconnect();
  
  const [tokenAAmount, setTokenAAmount] = useState('');
  const [tokenBAmount, setTokenBAmount] = useState('');
  
  const calculateSwapOutput = async (inputAmount: string) => {
    if (!inputAmount || !isConnected) return;
    
    const provider = new ethers.providers.Web3Provider(window.ethereum);
    const signer = provider.getSigner();
    
    // Uniswap Routeråˆçº¦
    const routerContract = new ethers.Contract(
      ROUTER_ADDRESS,
      ROUTER_ABI,
      signer
    );
    
    try {
      const amountIn = ethers.utils.parseEther(inputAmount);
      const path = [TOKEN_A_ADDRESS, TOKEN_B_ADDRESS];
      
      const amounts = await routerContract.getAmountsOut(amountIn, path);
      const outputAmount = ethers.utils.formatEther(amounts[1]);
      
      setTokenBAmount(outputAmount);
    } catch (error) {
      console.error('Swap calculation failed:', error);
    }
  };
  
  const executeSwap = async () => {
    if (!isConnected || !tokenAAmount) return;
    
    const provider = new ethers.providers.Web3Provider(window.ethereum);
    const signer = provider.getSigner();
    
    const routerContract = new ethers.Contract(
      ROUTER_ADDRESS,
      ROUTER_ABI,
      signer
    );
    
    try {
      const amountIn = ethers.utils.parseEther(tokenAAmount);
      const amountOutMin = ethers.utils.parseEther(tokenBAmount).mul(95).div(100); // 5% æ»‘ç‚¹
      const path = [TOKEN_A_ADDRESS, TOKEN_B_ADDRESS];
      const deadline = Math.floor(Date.now() / 1000) + 60 * 20; // 20åˆ†é’Ÿ
      
      const tx = await routerContract.swapExactTokensForTokens(
        amountIn,
        amountOutMin,
        path,
        address,
        deadline
      );
      
      await tx.wait();
      console.log('Swap completed:', tx.hash);
    } catch (error) {
      console.error('Swap failed:', error);
    }
  };
  
  return (
    <div className="swap-container">
      {!isConnected ? (
        <div>
          {connectors.map((connector) => (
            <button key={connector.id} onClick={() => connect({ connector })}>
              Connect {connector.name}
            </button>
          ))}
        </div>
      ) : (
        <div>
          <p>Connected: {address}</p>
          <button onClick={() => disconnect()}>Disconnect</button>
          
          <div className="swap-form">
            <input
              type="number"
              placeholder="Token A Amount"
              value={tokenAAmount}
              onChange={(e) => {
                setTokenAAmount(e.target.value);
                calculateSwapOutput(e.target.value);
              }}
            />
            <input
              type="number"
              placeholder="Token B Amount"
              value={tokenBAmount}
              readOnly
            />
            <button onClick={executeSwap}>Swap</button>
          </div>
        </div>
      )}
    </div>
  );
}
```

## ğŸ› ï¸ å¼€å‘ç¯å¢ƒæ­å»º

### Hardhaté¡¹ç›®åˆå§‹åŒ–

#### é¡¹ç›®ç»“æ„
```
my-defi-project/
â”œâ”€â”€ contracts/
â”‚   â”œâ”€â”€ MyToken.sol
â”‚   â”œâ”€â”€ StakingPool.sol
â”‚   â””â”€â”€ interfaces/
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ deploy.js
â”‚   â””â”€â”€ interact.js
â”œâ”€â”€ test/
â”‚   â”œâ”€â”€ MyToken.test.js
â”‚   â””â”€â”€ StakingPool.test.js
â”œâ”€â”€ hardhat.config.js
â””â”€â”€ package.json
```

#### Hardhaté…ç½®
```javascript
// hardhat.config.js
require("@nomicfoundation/hardhat-toolbox");
require("dotenv").config();

module.exports = {
  solidity: {
    version: "0.8.19",
    settings: {
      optimizer: {
        enabled: true,
        runs: 200
      }
    }
  },
  networks: {
    hardhat: {
      chainId: 31337
    },
    goerli: {
      url: `https://goerli.infura.io/v3/${process.env.INFURA_PROJECT_ID}`,
      accounts: [process.env.PRIVATE_KEY]
    },
    polygon: {
      url: "https://polygon-rpc.com/",
      accounts: [process.env.PRIVATE_KEY]
    }
  },
  etherscan: {
    apiKey: process.env.ETHERSCAN_API_KEY
  }
};
```

### æ™ºèƒ½åˆçº¦æµ‹è¯•

#### å•å…ƒæµ‹è¯•ç¤ºä¾‹
```javascript
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("MyToken", function () {
  let myToken;
  let owner;
  let addr1;
  let addr2;

  beforeEach(async function () {
    [owner, addr1, addr2] = await ethers.getSigners();
    
    const MyToken = await ethers.getContractFactory("MyToken");
    myToken = await MyToken.deploy();
    await myToken.deployed();
  });

  describe("Deployment", function () {
    it("Should set the right owner", async function () {
      expect(await myToken.owner()).to.equal(owner.address);
    });

    it("Should assign the total supply of tokens to the owner", async function () {
      const ownerBalance = await myToken.balanceOf(owner.address);
      expect(await myToken.totalSupply()).to.equal(ownerBalance);
    });
  });

  describe("Minting", function () {
    it("Should mint tokens to specified address", async function () {
      const mintAmount = ethers.utils.parseEther("1000");
      
      await myToken.mint(addr1.address, mintAmount);
      
      expect(await myToken.balanceOf(addr1.address)).to.equal(mintAmount);
    });

    it("Should fail if trying to mint more than max supply", async function () {
      const maxSupply = ethers.utils.parseEther("1000000");
      const currentSupply = await myToken.totalSupply();
      const excessAmount = maxSupply.sub(currentSupply).add(1);
      
      await expect(
        myToken.mint(addr1.address, excessAmount)
      ).to.be.revertedWith("Exceeds max supply");
    });
  });
});
```

## ğŸ“Š Web3ç”Ÿæ€åˆ†æ

### DeFiåè®®å¯¹æ¯”

#### ä¸»æµåè®®ç‰¹ç‚¹
| åè®® | ç±»å‹ | TVL | ç‰¹ç‚¹ | æŠ€æœ¯äº®ç‚¹ |
|------|------|-----|------|----------|
| **Uniswap** | DEX | $3B+ | AMMå…ˆé©± | æ’å®šä¹˜ç§¯å…¬å¼ |
| **Compound** | å€Ÿè´· | $2B+ | åˆ©ç‡æ¨¡å‹ | ç®—æ³•åŒ–åˆ©ç‡ |
| **Aave** | å€Ÿè´· | $5B+ | é—ªç”µè´· | ä¿¡ç”¨å§”æ‰˜ |
| **MakerDAO** | ç¨³å®šå¸ | $8B+ | å»ä¸­å¿ƒåŒ– | å¤šæŠµæŠ¼å“ |
| **Curve** | DEX | $2B+ | ç¨³å®šå¸äº¤æ˜“ | ä½æ»‘ç‚¹ç®—æ³• |

### Gasè´¹ç”¨ä¼˜åŒ–

#### å¸¸è§ä¼˜åŒ–æŠ€å·§
```solidity
// 1. ä½¿ç”¨packedç»“æ„ä½“
struct PackedData {
    uint128 amount;     // 16 bytes
    uint64 timestamp;   // 8 bytes  
    uint32 rate;        // 4 bytes
    bool isActive;      // 1 byte -> total 29 bytes, fits in 32 bytes
}

// 2. æ‰¹é‡æ“ä½œ
function batchTransfer(address[] calldata recipients, uint256[] calldata amounts) external {
    require(recipients.length == amounts.length, "Arrays length mismatch");
    
    for (uint256 i = 0; i < recipients.length; i++) {
        _transfer(msg.sender, recipients[i], amounts[i]);
    }
}

// 3. ä½¿ç”¨mappingä»£æ›¿array
mapping(address => bool) public whitelist; // æ›´çœgas
// address[] public whitelistArray; // è¾ƒè€—gas

// 4. äº‹ä»¶æ›¿ä»£å­˜å‚¨
event DataUpdated(address indexed user, uint256 value);
// è€Œéå­˜å‚¨åœ¨åˆçº¦çŠ¶æ€ä¸­
```

## ğŸ¯ å­¦ä¹ è·¯å¾„æ¨è

### åˆå­¦è€…è·¯å¾„ (1-3ä¸ªæœˆ)
```
åŸºç¡€æ¦‚å¿µ:
â€¢ åŒºå—é“¾åŸç†å’Œå…±è¯†æœºåˆ¶
â€¢ ä»¥å¤ªåŠåŸºç¡€å’Œè´¦æˆ·æ¨¡å‹  
â€¢ æ™ºèƒ½åˆçº¦æ¦‚å¿µå’Œç”¨é€”
â€¢ DeFiåŸºç¡€æ¦‚å¿µå’Œåè®®

å®è·µé¡¹ç›®:
â€¢ éƒ¨ç½²ç®€å•ERC-20ä»£å¸
â€¢ åˆ›å»ºåŸºç¡€NFTåˆçº¦
â€¢ ä½¿ç”¨Metamaskå’Œæµ‹è¯•ç½‘
â€¢ ä½“éªŒä¸»æµDeFiåè®®
```

### è¿›é˜¶è·¯å¾„ (3-6ä¸ªæœˆ)
```
æ·±å…¥æŠ€æœ¯:
â€¢ Solidityé«˜çº§ç‰¹æ€§
â€¢ åˆçº¦å®‰å…¨æœ€ä½³å®è·µ
â€¢ Gasä¼˜åŒ–æŠ€å·§
â€¢ è·¨é“¾æŠ€æœ¯åŸç†

é¡¹ç›®å®æˆ˜:
â€¢ å¼€å‘å®Œæ•´çš„DeFiåè®®
â€¢ å®ç°DAOæ²»ç†åˆçº¦
â€¢ æ„å»ºNFTäº¤æ˜“å¸‚åœº
â€¢ é›†æˆå¤šç§Web3æœåŠ¡
```

### ä¸“å®¶è·¯å¾„ (6ä¸ªæœˆ+)
```
å‰æ²¿æŠ€æœ¯:
â€¢ Layer 2æ‰©å®¹æ–¹æ¡ˆ
â€¢ MEVå’Œå¥—åˆ©ç­–ç•¥
â€¢ åè®®å®‰å…¨å®¡è®¡
â€¢ ç»æµæ¨¡å‹è®¾è®¡

ä¸“ä¸šå‘å±•:
â€¢ å¼€æºé¡¹ç›®è´¡çŒ®
â€¢ æŠ€æœ¯ç¤¾åŒºå»ºè®¾
â€¢ å®‰å…¨å®¡è®¡æœåŠ¡
â€¢ åè®®è®¾è®¡å’¨è¯¢
```

## ğŸš€ è¡Œä¸šåº”ç”¨å‰æ™¯

### æŠ€æœ¯å‘å±•è¶‹åŠ¿
```
çŸ­æœŸè¶‹åŠ¿ (1-2å¹´):
â€¢ Layer 2å¤§è§„æ¨¡é‡‡ç”¨
â€¢ è·¨é“¾äº’æ“ä½œæ€§æ”¹å–„
â€¢ æœºæ„çº§DeFiäº§å“
â€¢ NFTå®ç”¨æ€§å¢å¼º

ä¸­æœŸè¶‹åŠ¿ (2-5å¹´):
â€¢ å¤®è¡Œæ•°å­—è´§å¸æ™®åŠ
â€¢ Web3ç¤¾äº¤ç½‘ç»œå…´èµ·
â€¢ å»ä¸­å¿ƒåŒ–èº«ä»½ç³»ç»Ÿ
â€¢ å…ƒå®‡å®™åŸºç¡€è®¾æ–½

é•¿æœŸæ„¿æ™¯ (5å¹´+):
â€¢ å®Œå…¨å»ä¸­å¿ƒåŒ–äº’è”ç½‘
â€¢ ç¨‹åºåŒ–ç»æµå’ŒDAO
â€¢ äººå·¥æ™ºèƒ½ä¸åŒºå—é“¾èåˆ
â€¢ é‡å­å®‰å…¨å¯†ç å­¦
```

### èŒä¸šå‘å±•æœºä¼š
```
æŠ€æœ¯å²—ä½:
â€¢ æ™ºèƒ½åˆçº¦å¼€å‘å·¥ç¨‹å¸ˆ
â€¢ åŒºå—é“¾æ¶æ„å¸ˆ
â€¢ DeFiåè®®å¼€å‘è€…
â€¢ Web3å‰ç«¯å·¥ç¨‹å¸ˆ

äº§å“å²—ä½:
â€¢ åŒºå—é“¾äº§å“ç»ç†
â€¢ Tokenç»æµå­¦è®¾è®¡å¸ˆ
â€¢ DAOæ²»ç†ä¸“å®¶
â€¢ NFTé¡¹ç›®è¿è¥

å®‰å…¨å²—ä½:
â€¢ æ™ºèƒ½åˆçº¦å®¡è®¡å¸ˆ
â€¢ åŒºå—é“¾å®‰å…¨ç ”ç©¶å‘˜
â€¢ åè®®å®‰å…¨é¡¾é—®
â€¢ åŠ å¯†è´§å¸åˆ†æå¸ˆ
``` 